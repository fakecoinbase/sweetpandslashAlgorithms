Union Find:

Data sturctures:
a dictionary to store the tuples of
the infecting node x : a set containing the community IDs of good nodes infected by x.
a Counter to store
each community ID : the times that it is infected by some initial nodes
Algorithm:
Step1: (We want compute connected components (communities) for all 'good' nodes. If there is an edge between 2 'good' nodes, then union/connect them.)

for u, v in all combinations of good nodes pairs:
if there is an edge between u and v
if the size of set that where u is currently in is larger than that where v in in
- add the size of v to size u
- size v's parent become u
else:
- add the size of u to size v
- size u's parent become v
Step2: bridge/connect the bad nodes to good communities. If there is an edge between a 'bad' initial node and a good node in a good community, then add the good community ID to that bad node's set.

Step3:

for each bad initial node x,
for each good community y it infects
if y only can be infected by x
add the size of the community y to the number of nodes that can surivive if removed 'x'
Compleixity analysis:

Time: O(N^2). Assume in the worst case, there is N good nodes. For each good node, we need to check N^2 edges for union the graph, so the overall complexity is O(N^2).
Space: O(N) for parents, size, and the Counter() and defaultdict(set) data structures.
